// BOJ 1463. 1로 만들기 / S3
#include <iostream>
#include <vector>

using namespace std;

int dp[1000001] = { 0 };

int main() {

	for (int i = 2; i < 1000001; i++) {
		int a = 10000001;

		if (i % 3 == 0) a = dp[i / 3] + 1;
		if (i % 2 == 0 && a > dp[i / 2] + 1) a = dp[i / 2] +1;
		if (a > dp[i - 1] + 1) a = dp[i - 1] + 1;
		dp[i] = a;
		/*cout << dp[i] << ' ';*/
	}
	int N;
	cin >> N;

	cout << dp[N];
}

/*
3으로 나누거나, 2로 나누거나, 1을 빼는 과정을 통해 1을 만드는 것이 목표이고 그 횟수의 최솟값을 구해야 함.
그 의미는 다이나믹프로그래밍 사용해야 한다는 의미
일단 3으로 나누는게 가장 효율적인 방법이므로
a를 횟수의 최솟값이라 하고 3으로 나누어진다면 3으로 나누었을 떄 그 숫자가 1이 되기 위한 최솟값 + 1을 해주고
2로 나누어 지고 2으로 나누었을 떄 그 숫자가 1이 되기 위한 최솟값 + 1 이 기존 최솟값(3으로 나눈 과정을 통해 구한 최솟값)보다 작다면 그것을 최솟값으로 하고
3으로 2로 둘다 나누어지지 않으면 -1 했으 떄 그 숫자가 1이 되기 위한 최솟값 + 1
이 과정을 통해 dp를 완성한 후 요구하는 값 출력

예시를 들면 dp[10]의 경우
dp[9]+1, dp[5]+1 중 최솟값
dp[9]는 dp[3]+1과 dp[8]+1중 최솟값인데 dp[3] = 1이므로 dp[9] = 2
dp[5]는 dp[4]+1 이므로 dp[5] = 3
그러므로 dp[10] = dp[9] + 1 = 3이 나오게 된다.
*/